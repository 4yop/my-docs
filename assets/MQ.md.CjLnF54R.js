import{_ as t,c as e,o as r,ae as b}from"./chunks/framework.CmsL9_ih.js";const c=JSON.parse('{"title":"rabbitmq","description":"","frontmatter":{},"headers":[],"relativePath":"MQ.md","filePath":"MQ.md"}'),i={name:"MQ.md"};function o(l,a,d,h,q,k){return r(),e("div",null,[...a[0]||(a[0]=[b('<h1 id="rabbitmq" tabindex="-1">rabbitmq <a class="header-anchor" href="#rabbitmq" aria-label="Permalink to &quot;rabbitmq&quot;">​</a></h1><h2 id="rabbitmq消费失败的原因" tabindex="-1">rabbitmq消费失败的原因? <a class="header-anchor" href="#rabbitmq消费失败的原因" aria-label="Permalink to &quot;rabbitmq消费失败的原因?&quot;">​</a></h2><blockquote><p>过期时间<br> 队列超长<br> 被拒绝<br> 无法路由<br> 处理失败</p></blockquote><h2 id="rabbitmq的延迟消息如何实现" tabindex="-1">rabbitmq的延迟消息如何实现? <a class="header-anchor" href="#rabbitmq的延迟消息如何实现" aria-label="Permalink to &quot;rabbitmq的延迟消息如何实现?&quot;">​</a></h2><blockquote><p>使用死信队列,给消息设置过期时间,如果过期了,就会投递到死信队列中,然后再消费该队列;可能造成对头阻塞,第一个没消费完,就能不能消费第二个;</p></blockquote><blockquote><p>用官方插件 rabbitmq_delayed_message_exchange;消息过期后保存在erlang的数据库中,然后定时器查询出消息,再投递到x-delayed-message的交换机中;可能丢失，数据库是单节点磁盘副本;不适合10W+场景,因为定时器太多,竞争系统资源,导致时间漂移；</p></blockquote><h2 id="rabbitmq是如何做消息分发-有几种工作模式" tabindex="-1">rabbitmq是如何做消息分发？有几种工作模式? <a class="header-anchor" href="#rabbitmq是如何做消息分发-有几种工作模式" aria-label="Permalink to &quot;rabbitmq是如何做消息分发？有几种工作模式?&quot;">​</a></h2><table tabindex="0"><thead><tr><th>模式</th><th>概念</th><th>使用场景</th></tr></thead><tbody><tr><td>简单模式</td><td>一个生产者发送消息到一个队列，一个消费者从队列中接收消息。</td><td>简单的消息传递场景，如日志收集、任务分发等。</td></tr><tr><td>工作模式</td><td>多个消费者处理同一个队列中的消息。</td><td>处理大量消息的场景，如批量数据处理、订单处理等。</td></tr><tr><td>发布订阅模式</td><td>消息生产者将消息发送到交换机，交换机将消息广播到所有与之绑定的队列中，每个队列中的消费者都能接收到消息。</td><td>一对多或多对多消息传递的场景，如实时消息通知、系统日志广播等。</td></tr><tr><td>路由模式</td><td>消息生产者将消息发送到交换机，交换机根据路由键将消息发送到匹配的队列中，消费者从特定队列接收消息。</td><td>基于不同条件将消息路由到不同处理逻辑的场景，如订单状态更新、事件处理等。</td></tr><tr><td>主题模式</td><td>类似于路由模式，路由键支持通配符，可以匹配多个模式。交换机根据路由键的匹配结果将消息发送到匹配的队列中。(*:一个单词;#:多个单词)</td><td>复杂条件进行消息路由的场景，如多级分类的日志处理、基于用户兴趣的消息推送等。</td></tr><tr><td>RPC模式</td><td>远程过程调用，客户端发送请求消息到队列，服务端从队列接收请求并执行相应操作，然后将结果发送回客户端。</td><td>跨服务或跨语言的远程调用场景，如分布式系统中的服务调用、跨语言集成等。</td></tr></tbody></table><h2 id="rabbitmq的整体架构" tabindex="-1">rabbitmq的整体架构? <a class="header-anchor" href="#rabbitmq的整体架构" aria-label="Permalink to &quot;rabbitmq的整体架构?&quot;">​</a></h2><p>生产者:</p><p>vhost:rabbitmq虚拟主机的概念，对资源进行隔离和分组</p><p>exchange:消息发放和接收的中心</p><p>binding:</p><p>queue:消息存储和消费的地方</p><p>消费者:</p><h2 id="rabbitmq的死信队列" tabindex="-1">rabbitmq的死信队列 <a class="header-anchor" href="#rabbitmq的死信队列" aria-label="Permalink to &quot;rabbitmq的死信队列&quot;">​</a></h2><h2 id="rabbitmq如何保证高可用" tabindex="-1">rabbitmq如何保证高可用? <a class="header-anchor" href="#rabbitmq如何保证高可用" aria-label="Permalink to &quot;rabbitmq如何保证高可用?&quot;">​</a></h2><blockquote><p>普通集群:消息投递在不同的节点上; 镜像集群:每个节点上的消息都一样;</p></blockquote><h2 id="rabbitmq防止重复消费" tabindex="-1">rabbitmq防止重复消费? <a class="header-anchor" href="#rabbitmq防止重复消费" aria-label="Permalink to &quot;rabbitmq防止重复消费?&quot;">​</a></h2><blockquote><p>要选择合适的工作模式，比如：订阅消费路由主题模式会被投递到多个队列中，然后多个消费者消费; 判断幂等性,1锁,2判,3更新;主要是判断这里，比如加个uuid,消费后保存在redis中，然后查是否存在；判断表中唯一索引是否存在了;自动取消订单判断状态是否为未支付;</p></blockquote><h2 id="rabbitmq如何保证消息不丢失" tabindex="-1">rabbitmq如何保证消息不丢失? <a class="header-anchor" href="#rabbitmq如何保证消息不丢失" aria-label="Permalink to &quot;rabbitmq如何保证消息不丢失?&quot;">​</a></h2><blockquote><p>durable:丢able 生产者投递消息,用ack确认或事务(效率慢,txSelect:开启,txCommit:提交,txRollback:回滚) 交换机和队列声明时,参数durable为true,持久化; 消费者消费,用ack确认</p></blockquote><h2 id="rabbitmq如何保证消息有序性" tabindex="-1">rabbitmq如何保证消息有序性? <a class="header-anchor" href="#rabbitmq如何保证消息有序性" aria-label="Permalink to &quot;rabbitmq如何保证消息有序性?&quot;">​</a></h2><blockquote><p>消息发送，自己确保是有序的；集群化部署的话，可以通过分布式锁确保消息有序。<br> 消息到达队列之后，默认就是有序的。<br> 消息消费，一个队列对应一个消费者，并且一个消费者一个 channel，不能并发消费，就可以确保消息有序。</p></blockquote><h2 id="rabbitmq消息堆积如何解决" tabindex="-1">rabbitmq消息堆积如何解决? <a class="header-anchor" href="#rabbitmq消息堆积如何解决" aria-label="Permalink to &quot;rabbitmq消息堆积如何解决?&quot;">​</a></h2><blockquote><p>原因:要么投递太快，要么消费太慢<br> 生产消息的速度长时间远大于消费的速度。<br> 消费者出现异常，无法消费消息。<br> 消费者与队列间的订阅可能出现问题，导致消息无法被消费。<br> 消费者的消费能力降低，导致消息等待消费的时间过长。</p></blockquote><blockquote><p>解决: 排查是否为无法消费:被拒绝,无法路由等 优化代码，使得消费速度变快; 加多些消费者; 错峰处理; 限制生产者的速度; 设置消费者的最大消息数，当消息堆积达到一定数量时，停止接收新消息，直到已接收消息的数量减少到一定程度再继续接收。 升级配置</p></blockquote><h2 id="如何保证消息一定能发送到rabbitmq" tabindex="-1">如何保证消息一定能发送到rabbitmq? <a class="header-anchor" href="#如何保证消息一定能发送到rabbitmq" aria-label="Permalink to &quot;如何保证消息一定能发送到rabbitmq?&quot;">​</a></h2><blockquote><p>生产者投递消息,用ack确认或事务(效率慢,txSelect:开启,txCommit:提交,txRollback:回滚)</p></blockquote><h2 id="rabbitmq事务" tabindex="-1">rabbitmq事务 <a class="header-anchor" href="#rabbitmq事务" aria-label="Permalink to &quot;rabbitmq事务&quot;">​</a></h2><blockquote><p>生产者端投递，原子性，效率慢,</p><p>txSelect:开启,</p><p>txCommit:提交,</p><p>txRollback:回滚</p></blockquote><h2 id="rabbitmq如何实现消费端限流" tabindex="-1">rabbitmq如何实现消费端限流? <a class="header-anchor" href="#rabbitmq如何实现消费端限流" aria-label="Permalink to &quot;rabbitmq如何实现消费端限流?&quot;">​</a></h2><ul><li>prefetchSize：每条消息大小的设置，0是无限制</li><li>prefetchCount:标识每次推送多少条消息</li><li>global:false标识channel级别的 true:标识消费者级别的</li></ul><blockquote><p>channel.basicQos(0,10,false);</p></blockquote><h1 id="kafka" tabindex="-1">kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to &quot;kafka&quot;">​</a></h1><h2 id="kafka-的架构-大致储存结构" tabindex="-1">kafka 的架构，大致储存结构 <a class="header-anchor" href="#kafka-的架构-大致储存结构" aria-label="Permalink to &quot;kafka 的架构，大致储存结构&quot;">​</a></h2><h2 id="kafka如果消费者数超过分区数会怎么样" tabindex="-1">kafka如果消费者数超过分区数会怎么样？ <a class="header-anchor" href="#kafka如果消费者数超过分区数会怎么样" aria-label="Permalink to &quot;kafka如果消费者数超过分区数会怎么样？&quot;">​</a></h2><h2 id="kafka怎么保证数据的可靠投递" tabindex="-1">kafka怎么保证数据的可靠投递？ <a class="header-anchor" href="#kafka怎么保证数据的可靠投递" aria-label="Permalink to &quot;kafka怎么保证数据的可靠投递？&quot;">​</a></h2><h2 id="kafka消费者的-offset-存在哪里" tabindex="-1">kafka消费者的 offset 存在哪里？ <a class="header-anchor" href="#kafka消费者的-offset-存在哪里" aria-label="Permalink to &quot;kafka消费者的 offset 存在哪里？&quot;">​</a></h2><h2 id="kafka如何通过-offset-定位消息" tabindex="-1">kafka如何通过 offset 定位消息？ <a class="header-anchor" href="#kafka如何通过-offset-定位消息" aria-label="Permalink to &quot;kafka如何通过 offset 定位消息？&quot;">​</a></h2><h2 id="kafka时间轮的原理" tabindex="-1">kafka时间轮的原理 <a class="header-anchor" href="#kafka时间轮的原理" aria-label="Permalink to &quot;kafka时间轮的原理&quot;">​</a></h2><h2 id="kafka-写入高性能的原因-sendfile-和-mmap-原理-为什么不用-splice" tabindex="-1">kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice <a class="header-anchor" href="#kafka-写入高性能的原因-sendfile-和-mmap-原理-为什么不用-splice" aria-label="Permalink to &quot;kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice&quot;">​</a></h2>',42)])])}const n=t(i,[["render",o]]);export{c as __pageData,n as default};
