import{_ as e,c as o,o as i,ae as d}from"./chunks/framework.BQlYxExx.js";const p=JSON.parse('{"title":"Git 常用命令速查与协作指南","description":"一份完整的 Git 命令速查表，涵盖 Git init、clone、add、commit、push 等核心操作，以及 git reset、git revert、git cherry-pick 等高级用法，助力团队协作和冲突解决。","frontmatter":{"title":"Git 常用命令速查与协作指南","description":"一份完整的 Git 命令速查表，涵盖 Git init、clone、add、commit、push 等核心操作，以及 git reset、git revert、git cherry-pick 等高级用法，助力团队协作和冲突解决。","keywords":"Git, Git 命令, git init, git clone, git reset, git revert, git cherry-pick, 合并冲突, git push -f, 版本控制, 团队协作"},"headers":[],"relativePath":"GIT.md","filePath":"GIT.md"}'),c={name:"GIT.md"};function r(l,t,a,s,g,n){return i(),o("div",null,[...t[0]||(t[0]=[d(`<h1 id="git" tabindex="-1">GIT <a class="header-anchor" href="#git" aria-label="Permalink to &quot;GIT&quot;">​</a></h1><h2 id="git命令速查" tabindex="-1">git命令速查 <a class="header-anchor" href="#git命令速查" aria-label="Permalink to &quot;git命令速查&quot;">​</a></h2><table tabindex="0"><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>git init</code></td><td>初始化一个新的 Git 仓库</td></tr><tr><td><code>git clone &lt;repository&gt;</code></td><td>克隆（下载）一个远程仓库到本地</td></tr><tr><td><code>git add &lt;file&gt;</code></td><td>将文件添加到暂存区</td></tr><tr><td><code>git commit -m &lt;message&gt;</code></td><td>将暂存区的更改提交为一个新的提交</td></tr><tr><td><code>git status</code></td><td>显示工作区和暂存区的状态</td></tr><tr><td><code>git log</code></td><td>查看提交历史</td></tr><tr><td><code>git branch</code></td><td>列出本地分支</td></tr><tr><td><code>git checkout &lt;branch&gt;</code></td><td>切换到指定分支</td></tr><tr><td><code>git merge &lt;branch&gt;</code></td><td>将指定分支合并到当前分支</td></tr><tr><td><code>git pull</code></td><td>拉取远程仓库的更新并合并到当前分支</td></tr><tr><td><code>git push</code></td><td>推送当前分支的更改到远程仓库</td></tr><tr><td><code>git remote add &lt;name&gt; &lt;url&gt;</code></td><td>添加一个远程仓库</td></tr><tr><td><code>git remote -v</code></td><td>显示远程仓库的详细信息</td></tr><tr><td><code>git diff</code></td><td>显示工作区与暂存区之间的差异</td></tr><tr><td><code>git reset &lt;file&gt;</code></td><td>从暂存区中移除文件</td></tr><tr><td><code>git stash</code></td><td>将当前更改暂存起来并清空工作区</td></tr><tr><td><code>git cherry-pick &lt;commit&gt;</code></td><td>选择一个提交并将其应用到当前分支</td></tr><tr><td><code>git tag &lt;tagname&gt;</code></td><td>创建一个标签</td></tr><tr><td><code>git remote remove &lt;name&gt;</code></td><td>移除指定的远程仓库</td></tr><tr><td><code>git config --global &lt;option&gt;</code></td><td>配置全局 Git 选项</td></tr></tbody></table><h2 id="git的常用指令" tabindex="-1">git的常用指令? <a class="header-anchor" href="#git的常用指令" aria-label="Permalink to &quot;git的常用指令?&quot;">​</a></h2><p>我们要开始一个新项目。以下是在项目过程中可能会用到的 Git 指令：</p><blockquote><p>当我们开始搭建一个新的项目仓库，首先我们会用 <code>git init</code> 来初始化仓库；搭建好之后，我们会在 GitHub 或者 GitLab 上设置好公钥，以便能够进行安全的通信。</p></blockquote><blockquote><p>然后我们使用 <code>git clone [url]</code> 来克隆拉取仓库代码。因为是多人协作开发，所以每个人会用 <code>git branch [branch-name]</code> 来创建自己的分支。</p></blockquote><blockquote><p>开始编写代码，编写代码就使用 <code>git add [file]</code> 和 <code>git commit -m &quot;commit message&quot;</code> 和 <code>git push</code> 将更改提交到自己的分支上。</p></blockquote><blockquote><p>当我们准备将我们的更改合并到主分支时，我们会用 <code>git checkout master</code> 切换到主分支，然后使用 <code>git merge [branch-name]</code> 将我们的更改合并到主分支上。</p></blockquote><blockquote><p>在提交或合并的过程中，有可能出现代码冲突。当这种情况发生时，我们可以使用 <code>git diff</code> 来查看冲突的详细信息，然后手动解决冲突，并使用 <code>git add [file]</code> 和 <code>git commit -m &quot;resolve conflict&quot;</code> 来提交解决冲突后的代码。</p></blockquote><blockquote><p>在开发过程中，我们经常会遇到这样的情况：正在开发的时候，突然要加新功能，而且新功能比较急。这时我们可以使用 <code>git stash</code> 命令将当前的更改保存起来，然后切换到新的分支进行新功能的开发。等新功能开发完毕并合并到主分支后，我们再用 <code>git stash pop</code> 将之前保存的更改恢复，继续我们之前的工作。</p></blockquote><h2 id="git-init-和-git-init-bare-的区别" tabindex="-1">git init 和 git init --bare 的区别? <a class="header-anchor" href="#git-init-和-git-init-bare-的区别" aria-label="Permalink to &quot;git init 和 git init --bare 的区别?&quot;">​</a></h2><blockquote><p><code>git init</code> 和 <code>git init --bare</code> 都是 Git 命令，用于初始化一个新的 Git 仓库，但它们创建的仓库类型有所不同。</p></blockquote><blockquote><p>1.<code>git init</code> 命令用于创建一个标准的 Git 仓库。这个仓库包括一个 <code>.git</code> 子目录，它存储了所有的仓库元数据，以及一个工作目录，用于保存你的项目文件。这意味着你可以在这个工作目录中编辑你的文件，然后使用 <code>git add</code> 和 <code>git commit</code> 命令来保存你的更改。这是在你需要在本地进行开发工作时应该使用的仓库类型。</p></blockquote><blockquote><p>2.<code>git init --bare</code> 命令用于创建一个裸仓库（bare repository）。裸仓库只包含 Git 仓库的元数据，而没有工作目录。这意味着你不能直接在裸仓库中编辑或提交文件。裸仓库常常被用作共享仓库，例如在服务器上，让其他人可以克隆（clone）或推送（push）更改。这通常在你需要设置一个纯粹用于版本控制的仓库时使用，例如在服务器上托管的中央仓库。</p></blockquote><blockquote><p>所以，<code>git init</code> 创建的是一个有工作目录的仓库，用于日常的开发工作；而 <code>git init --bare</code> 创建的是没有工作目录的裸仓库，用于作为共享仓库，存储版本历史信息。</p></blockquote><h2 id="git-reset-和-git-revert-的-区别" tabindex="-1">git reset 和 git revert 的 区别? <a class="header-anchor" href="#git-reset-和-git-revert-的-区别" aria-label="Permalink to &quot;git reset 和 git revert 的 区别?&quot;">​</a></h2><blockquote><p><strong>git revert</strong> 和 <strong>git reset</strong> 都是用来撤销 Git 历史的命令，但它们的工作方式和使用场景有所不同。</p></blockquote><blockquote><ul><li><strong>git reset</strong> 是一个强大的命令，它能将 HEAD 指针移动到指定的提交，同时可以选择性地修改暂存区或工作目录以匹配该提交。<code>git reset</code> 有三种模式： <ul><li><code>git reset --soft</code> 仅移动 HEAD 指针而不更改暂存区和工作目录。</li><li><code>git reset --mixed</code>（默认） 移动 HEAD 并更改暂存区以匹配该提交，但不影响工作目录。</li><li><code>git reset --hard</code> 移动 HEAD 并更改暂存区和工作目录以匹配该提交。 这使得 <code>git reset</code> 成为一个灵活的命令，可以用于撤销更改或者清理工作区和暂存区。但是，它也有一个缺点，那就是它会重写 Git 历史，这可能会导致困扰如果与其他开发者共享了这些更改。</li></ul></li></ul></blockquote><blockquote><ul><li>相比之下，<strong>git revert</strong> 则会创建一个新的提交，这个提交的内容与要撤销的提交相反。这意味着它不会重写历史，这使得它成为一个更安全的选择，特别是在公共或者团队的环境中。当你想要撤销某个提交的更改，但又不想影响项目的历史时，你应该使用 <code>git revert</code>。</li></ul></blockquote><blockquote><p>总的来说，<code>git reset</code> 是一个更强大且灵活的命令，但也更危险。<code>git revert</code> 则是一个更安全的选择，特别是在团队环境中。选择使用哪个命令主要取决于你的具体需求以及你的工作环境。</p></blockquote><h2 id="git-cherry-pick-它是什么命令" tabindex="-1">git cherry-pick 它是什么命令？ <a class="header-anchor" href="#git-cherry-pick-它是什么命令" aria-label="Permalink to &quot;git cherry-pick 它是什么命令？&quot;">​</a></h2><blockquote><p><strong>git cherry-pick</strong> 是一个非常实用的 Git 命令，它允许你将一个特定的提交从一个分支复制（或“挑选”）到当前的分支。这在许多情况下都非常有用，例如你想要获取一个在其他分支上的修复，但是并不想合并整个分支。</p></blockquote><blockquote><p>使用 <code>git cherry-pick</code> 的基本语法如下：</p></blockquote><blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cherry-pick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">commit-has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span></span></code></pre></div></blockquote><blockquote><p>在这里，<code>&lt;commit-hash&gt;</code> 是你想要挑选的提交的哈希值。执行这个命令后，Git 会在当前分支上创建一个新的提交，这个提交的更改集与你挑选的提交一样。请注意，这个新的提交是一个全新的提交，它有自己的哈希值，尽管它的更改集与原始提交相同。</p></blockquote><blockquote><p>总的来说，<code>git cherry-pick</code> 是一个非常强大的工具，可以帮助你精确地管理你的提交和分支。</p></blockquote><h2 id="如何处理合并冲突的" tabindex="-1">如何处理合并冲突的？ <a class="header-anchor" href="#如何处理合并冲突的" aria-label="Permalink to &quot;如何处理合并冲突的？&quot;">​</a></h2><blockquote><p>解决冲突的关键是理解冲突的本质：两个或更多的开发者试图修改同一个地方。你的任务是决定最终的文件应该是什么样的。有了这个思路，解决冲突就会变得更容易。</p></blockquote><blockquote><p>当在使用 Git 进行协同开发时，代码冲突是常见的问题。它通常发生在两个或更多的开发者尝试修改同一个文件的同一部分时。解决冲突的过程通常需要人工介入，以下是解决冲突的一般步骤：</p></blockquote><blockquote><ol><li><strong>定位冲突</strong>：首先，Git 会告诉你哪些文件存在冲突。你可以通过运行 <code>git status</code> 命令来查看这些文件。</li></ol></blockquote><blockquote><ol start="2"><li><strong>打开冲突文件</strong>：然后，你需要打开这些存在冲突的文件，查看冲突的具体位置。Git 会在文件中插入标准的冲突解决标记，这可以帮助你找到冲突的位置。这些标记看起来像这样：</li></ol></blockquote><blockquote><div class="language-markdown vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">markdown</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(你的更改)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-light-font-weight:bold;--shiki-dark:#79B8FF;--shiki-dark-font-weight:bold;">=======</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(对方的更改)</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-name</span></span></code></pre></div></blockquote><blockquote><ol start="3"><li><strong>解决冲突</strong>：接下来，你需要手动编辑这些文件，决定应该保留哪些更改。你可以选择保留你的更改，保留对方的更改，或者合并你们的更改。在你决定好之后，删除 Git 插入的冲突解决标记。</li></ol></blockquote><blockquote><ol start="4"><li><strong>提交解决冲突后的文件</strong>：最后，当你解决了所有冲突后，运行 <code>git add</code> 命令来更新暂存区，然后运行 <code>git commit</code> 来提交你的更改。这时，Git 会自动创建一个新的合并提交，表示你已经解决了所有的冲突。</li></ol></blockquote><h2 id="为什么在团队协助中-不能用-push-f-去推代码" tabindex="-1">为什么在团队协助中 不能用 push -f 去推代码？ <a class="header-anchor" href="#为什么在团队协助中-不能用-push-f-去推代码" aria-label="Permalink to &quot;为什么在团队协助中 不能用 push -f 去推代码？&quot;">​</a></h2><blockquote><p>使用 <code>git push -f</code> 或 <code>git push --force</code> 命令会强制 Git 将你本地的分支推送到远程仓库，即使这意味着会覆盖远程仓库中现有的提交。这就是为什么在团队协作中，你应该避免使用这个命令。</p></blockquote><blockquote><p>以下是几个关键的原因：</p></blockquote><blockquote><ol><li><strong>会丢失他人的工作</strong>：如果你的团队成员已经在同一个分支上推送了他们的更改，然后你用 <code>git push -f</code> 推送你的更改，他们的更改就会被你的更改覆盖，从而导致他们的工作丢失。</li></ol></blockquote><blockquote><ol start="2"><li><strong>破坏仓库的历史</strong>：<code>git push -f</code> 会改写远程仓库的历史，这会使得理解项目的历史变得更困难。例如，如果你用 <code>git push -f</code> 命令覆盖了一个已经发布的版本，那么你的团队就无法准确地知道哪个提交是发布的一部分。</li></ol></blockquote><blockquote><ol start="3"><li><strong>引发混乱</strong>：如果你强制推送了更改，那么你的团队成员在拉取最新的代码时可能会遇到各种问题。例如，他们可能会看到一些他们从未见过的冲突，或者他们的 Git 历史可能会与实际的项目历史不一致。</li></ol></blockquote><blockquote><p>总的来说，虽然 <code>git push -f</code> 在某些情况下可能会有用（例如，你在自己的私有分支上工作，或者你需要修正一个你自己刚刚推送的错误提交），但在团队协作中，你应该尽量避免使用这个命令。</p></blockquote><h2 id="git-查看别人的某一次提交内容-回滚某一次或多次提交的内容" tabindex="-1">git 查看别人的某一次提交内容，回滚某一次或多次提交的内容 <a class="header-anchor" href="#git-查看别人的某一次提交内容-回滚某一次或多次提交的内容" aria-label="Permalink to &quot;git 查看别人的某一次提交内容，回滚某一次或多次提交的内容&quot;">​</a></h2><p><code>git show &lt;commit-id&gt;</code></p><p><code>git revert &lt;commit-id&gt; -m 1 </code></p>`,45)])])}const k=e(c,[["render",r]]);export{p as __pageData,k as default};
