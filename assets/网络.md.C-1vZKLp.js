import{_ as e,c as a,o as r,ae as n}from"./chunks/framework.BQlYxExx.js";const l="/assets/httpvshttps.DGRzuaPm.png",i="/assets/https.Dr1GE2my.png",T=JSON.parse('{"title":"HTTP","description":"","frontmatter":{},"headers":[],"relativePath":"网络.md","filePath":"网络.md"}'),o={name:"网络.md"};function s(d,t,h,c,p,b){return r(),a("div",null,[...t[0]||(t[0]=[n('<h2 id="网络有哪几层" tabindex="-1">网络有哪几层？ <a class="header-anchor" href="#网络有哪几层" aria-label="Permalink to &quot;网络有哪几层？&quot;">​</a></h2><blockquote><p>应用层:http,ssh，stmp,dns等<br> 表示层:<br> 会话层:<br> 传输层:TCP,UDP<br> 网络层:ip，arp，<br> 数据链路层:<br> 物理层:</p></blockquote><h2 id="http常用的请求方式和用途" tabindex="-1">HTTP常用的请求方式和用途？ <a class="header-anchor" href="#http常用的请求方式和用途" aria-label="Permalink to &quot;HTTP常用的请求方式和用途？&quot;">​</a></h2><blockquote><p>GET：获取数据<br> POST：提交数据<br> PUT：提交修改数据<br> DELETE：删除<br> HEAD:获取头部信息<br> CONNECT：建立连接隧道，用于代理服务器<br> OPTIONS：列出可对资源请求的方法，常用于跨域<br> TRACE：追踪请求，响应传输的数据</p></blockquote><h2 id="cors跨域" tabindex="-1">CORS跨域 <a class="header-anchor" href="#cors跨域" aria-label="Permalink to &quot;CORS跨域&quot;">​</a></h2><h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><h2 id="http-请求的方法-head-option-patch-什么是-restful-https-的握手过程-哪四次-有什么区别" tabindex="-1">Http 请求的方法 HEAD？OPTION？PATCH，什么是 restful？Https 的握手过程？哪四次？有什么区别？ <a class="header-anchor" href="#http-请求的方法-head-option-patch-什么是-restful-https-的握手过程-哪四次-有什么区别" aria-label="Permalink to &quot;Http 请求的方法 HEAD？OPTION？PATCH，什么是 restful？Https 的握手过程？哪四次？有什么区别？&quot;">​</a></h2><h2 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-label="Permalink to &quot;状态码&quot;">​</a></h2><h3 id="http常用状态码" tabindex="-1">HTTP常用状态码 <a class="header-anchor" href="#http常用状态码" aria-label="Permalink to &quot;HTTP常用状态码&quot;">​</a></h3><p>101 ：Switching Protocols,请求切换协议，比如：http切换为websocket</p><p>200：OK,请求成功</p><p>204：No Content，成功状态码，但响应头没有body数据</p><p>301：Moved Permanently，永久重定向，请求的资源不在了，需要改用新url访问</p><p>302：Found,临时重定向，请求的资源还在，但暂时需要另一个url</p><p>304：Not Modified,客户端缓存的资源是最新的，不需要重新获取</p><p>400：Bad Request,请求报文语法错误</p><p>403：Forbidden,禁止访问的资源</p><p>404：Not Found,访问的资源不存在或找不到</p><p>500：Internal Server Error,服务器发生了错误</p><p>502：Bad Gateway，网关出错</p><p>503：Service Unavailable,服务器维护或者过载,服务不可用，无法处理</p><p>504：Gateway Timeout,网关超时</p><h3 id="_301和302的区别" tabindex="-1">301和302的区别 <a class="header-anchor" href="#_301和302的区别" aria-label="Permalink to &quot;301和302的区别&quot;">​</a></h3><blockquote><p>301:表示url已永久转移到了新的url上，以后都用这个新的url，浏览器会缓存这个重定向，以后都直接访问新url<br> 302:表示只是临时移动了新的位置，但原url还是有效的，浏览器不会缓存，</p></blockquote><h3 id="_500原因-处理" tabindex="-1">500原因？处理？ <a class="header-anchor" href="#_500原因-处理" aria-label="Permalink to &quot;500原因？处理？&quot;">​</a></h3><blockquote><p>解决：<br> 查看nginx，php的日志,看有没有错误记录；<br> 如果是too many open files，修改nginx的worker_rlimit_nofile参数，使用ulimit查看系统打开文件限制，修改/etc/security/limits.conf，还是出现too many open files，那就要考虑做负载均衡，把流量分散到不同服务器上去<br> 如果是脚本问题，修改脚本错误，优化代码</p></blockquote><h3 id="_502原因-处理" tabindex="-1">502原因？处理？ <a class="header-anchor" href="#_502原因-处理" aria-label="Permalink to &quot;502原因？处理？&quot;">​</a></h3><blockquote><p>Bad Gateway,作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br> Nginx将请求提交给网关(php-fpm)处理异常<br> php-fpm的问题:进程数设置太少，无法处理大量请求；<br> nginx配置问题：缓冲区设置过小，fastcgi_buffers 8 16k 或 fastcgi_buffer_size 32k 设置过小，无法容纳php-fpm返回大量数据；<br> 资源不足：cpu，内存等不足使php-fpm无法处理；<br> 网络问题：nginx和php-fpm的网络不稳定或延迟<br> 注：location ~ .php$ {<br> include snippets/fastcgi-php.conf;<br> //设置为sock或tcp<br> fastcgi_pass unix:/var/run/php/php-fpm.sock;<br> fastcgi_pass 127.0.0.1:9000;<br> }</p></blockquote><h3 id="_503原因-处理" tabindex="-1">503原因？处理？ <a class="header-anchor" href="#_503原因-处理" aria-label="Permalink to &quot;503原因？处理？&quot;">​</a></h3><blockquote><p>服务不可用，可能请求过载，限流等<br> 比如:nginx 设置了 每个ip的连接数限制(limit_conn)或请求数限制(limit_req)</p></blockquote><h3 id="_504原因-处理" tabindex="-1">504原因？处理？ <a class="header-anchor" href="#_504原因-处理" aria-label="Permalink to &quot;504原因？处理？&quot;">​</a></h3><blockquote><p>Gateway timeout网关超时； 可能因为程序的执行时间超过了nginx的等待时间 php执行时间超过nginx等待时间:php的max_execution_time设置不合里<br> nginx等待时间过短：fastcgi_connect_timeout，fastcgi_read_timeout，fastcgi_send_timeout，导致php未处理完就关闭连接<br> 网络问题：nginx和php-fpm的网络不稳定或延迟<br> 注：location ~ .php$ {<br> include snippets/fastcgi-php.conf;<br> //设置为sock或tcp<br> fastcgi_pass unix:/var/run/php/php-fpm.sock;<br> fastcgi_pass 127.0.0.1:9000;<br> }</p></blockquote><h2 id="get和post的区别" tabindex="-1">GET和POST的区别？ <a class="header-anchor" href="#get和post的区别" aria-label="Permalink to &quot;GET和POST的区别？&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">GET</th><th style="text-align:center;">POST</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>用途</strong></td><td style="text-align:center;">获取资源</td><td style="text-align:center;">提交数据</td></tr><tr><td style="text-align:center;"><strong>参数显示</strong></td><td style="text-align:center;">参数在URL</td><td style="text-align:center;">参数不会URL</td></tr><tr><td style="text-align:center;"><strong>参数长度限制</strong></td><td style="text-align:center;">长度受限于浏览器</td><td style="text-align:center;">没有参数长度限制</td></tr><tr><td style="text-align:center;"><strong>安全性</strong></td><td style="text-align:center;">较低，历史记录看见</td><td style="text-align:center;">较高</td></tr><tr><td style="text-align:center;"><strong>幂等性</strong></td><td style="text-align:center;">是，多次请求同一URL，结果相同</td><td style="text-align:center;">否，多次请求可能产生不同的结果，或产生副作用</td></tr><tr><td style="text-align:center;"><strong>缓存</strong></td><td style="text-align:center;">可</td><td style="text-align:center;">不</td></tr><tr><td style="text-align:center;"><strong>后退/刷新按钮</strong></td><td style="text-align:center;">无害，可以安全使用</td><td style="text-align:center;">数据会被再次提交（F5刷新页面）</td></tr><tr><td style="text-align:center;"><strong>书签</strong></td><td style="text-align:center;">可以被书签保存</td><td style="text-align:center;">无法被书签保存</td></tr><tr><td style="text-align:center;"><strong>传输类型</strong></td><td style="text-align:center;">适用于请求数据</td><td style="text-align:center;">适用于提交数据</td></tr></tbody></table><h2 id="post和get那个更安全" tabindex="-1">POST和GET那个更安全？ <a class="header-anchor" href="#post和get那个更安全" aria-label="Permalink to &quot;POST和GET那个更安全？&quot;">​</a></h2><p>①如果是对于普通用户来说,post更安全，因为get网址(历史书签记)上能看到参数，而post网址看不到参数，刷新后退浏览器会有提示；<br> ②对于专业人员来看，都不安全，使用了https加密好些;<br> ③http协议上定义的安全请求是不会破坏资源，get是只读的，无论多多少次都是安全，结果都一样;post是提交数据会创建资源，所以是不幂等的;<br> ④取决开发者怎么用;</p><h2 id="cookie和session区别" tabindex="-1">COOKIE和SESSION区别？ <a class="header-anchor" href="#cookie和session区别" aria-label="Permalink to &quot;COOKIE和SESSION区别？&quot;">​</a></h2><p>1.cookie是服务端发送给客户端的，并保存在本地的数据，在浏览器下次向同一域名发起请求时会携带上cookie。用于告知多个请求是否来自于同一个用户，保持登录状态等。使基于HTTP无状态协议记录稳定的信息成为可能 2.因为http是无状态的协议，要识别哪些请求是有关联的；session指服务器和客户端一次会话的过程， 3.cookie存在客户端，session存在服务端 4.单个cookie长度有限制不能大于4k，session无限制 5.cookie不够安全可能，session依赖于cookie 6.客户端请求服务器创建session后，返回seseionid，保存在cookie那，下次请求携带上这个cookie，从而判断登录状态等</p><h1 id="http" tabindex="-1">HTTP <a class="header-anchor" href="#http" aria-label="Permalink to &quot;HTTP&quot;">​</a></h1><h2 id="http和https的区别" tabindex="-1">HTTP和HTTPS的区别？ <a class="header-anchor" href="#http和https的区别" aria-label="Permalink to &quot;HTTP和HTTPS的区别？&quot;">​</a></h2><blockquote><p>HTTP，超文本传输协议，是基于TCP/IP的通信协议；<br> HTTPS为了解决HTTP不安全的问题，使用SSL证书来验证服务器身份，并对传输数据进行加密;<br> 1.HTTP是明文传输，HTTPS是密文<br> 2.HTTP默认端口为80，HTTPS默认端口为443<br> 3.HTTPS消耗更多的资源，因为需要加密解密<br> 4.HTTP不安全，HTTPS安全；<br> 5.从浏览器同源策略上来说是不同的url，算跨域</p></blockquote><p><img src="'+l+'" alt="httpvshttps.png"></p><h2 id="http的请求过程和原理" tabindex="-1">HTTP的请求过程和原理？ <a class="header-anchor" href="#http的请求过程和原理" aria-label="Permalink to &quot;HTTP的请求过程和原理？&quot;">​</a></h2><p>HTTP是基于TCP/IP的超文本传输协议<br> 1.客户端DNS解析，得到IP地址<br> 2.对这个IP的服务器建立连接（三次握手）<br> 3.建立TCP连接后发起HTTP请求<br> 4.服务端处理请求后响应，的到html代码<br> 5.客户端解析html代码，渲染<br> 6.服务端关闭连接（四次挥手）</p><h2 id="https的流程是怎样的" tabindex="-1">HTTPS的流程是怎样的？ <a class="header-anchor" href="#https的流程是怎样的" aria-label="Permalink to &quot;HTTPS的流程是怎样的？&quot;">​</a></h2><p>1.用户在浏览器输入https的网址，然后连接到server的443端口 2.服务端有一套证书（公钥和私钥）,服务端将自己的公钥发送给客户端 3.客户端收到公钥后，进行校验，有问题就弹出警告；生成一个密钥（对称加密），用证书的公钥进行加密 4.客户端发起https中的第二个http请求，将加密的密钥发给服务端 5.服务端收到密文后，用私钥进行非对称解密，解密得到客户端密钥，然后用客户端密钥进行非对称加密，形成密文 6.服务端将密文发给客户端 7.客户端用客户端密钥对密文进行非对称解密得到数据 <img src="'+i+'" alt="https.png"></p><h2 id="http的几种缓存机制" tabindex="-1">HTTP的几种缓存机制？ <a class="header-anchor" href="#http的几种缓存机制" aria-label="Permalink to &quot;HTTP的几种缓存机制？&quot;">​</a></h2><p>1.强缓存:不会发起请求，直接从(客户端)缓存中读取资源; 打开chrome的控制台的network,请求的size变成from disk cache 或from memory cache; expires:过期时间; Cache-Control:max-age;一个过期就过期了;<br> 2.协商缓存:发起请求,request header带参数判断是否命中缓存, 命中就返回304并带上新的response header通知浏览器从(客户端)缓存中读取资源; Etag:唯一标识; If-None-Match, Last-Modified, If-Modified-Since</p><h2 id="对称加密和非对称加密区别" tabindex="-1">对称加密和非对称加密区别？ <a class="header-anchor" href="#对称加密和非对称加密区别" aria-label="Permalink to &quot;对称加密和非对称加密区别？&quot;">​</a></h2><p>1.对称加密：加密解密使用相同的密钥的加密算法 2.非对称加密：加密和解密使用公钥私钥的加密算法</p><h2 id="什么是xss攻击-如何避免" tabindex="-1">什么是XSS攻击？如何避免？ <a class="header-anchor" href="#什么是xss攻击-如何避免" aria-label="Permalink to &quot;什么是XSS攻击？如何避免？&quot;">​</a></h2><p>XSS攻击：跨站脚本攻击；在web里嵌入恶意代码，浏览网页时会执行，达到攻击目的 避免 1.用户传的参数有进行校验， 2.要进行hmtl转义（htmlspecialchars转义，strip_tags过滤html）<br> 3.对script a 标签等进行过滤,dom里的事件 4.限制输入长度 5.前端使用vue等mvvm框架，只有使用v-html才渲染html</p><h2 id="什么是csrf攻击-如何避免" tabindex="-1">什么是CSRF攻击？如何避免？ <a class="header-anchor" href="#什么是csrf攻击-如何避免" aria-label="Permalink to &quot;什么是CSRF攻击？如何避免？&quot;">​</a></h2><p>CSRF：跨站请求伪造攻击；盗用了你的身份，去做恶意请求； 比如：你A网站登陆了，点击一个B网站连接，这个网站跳转到A网站发红包的页面<br> 避免：<br> 1.添加refer字段标明来源；<br> 2.加token；<br> 3.尽量post请求，判断post请求的来源（$_SERVER[&#39;HTTP_REFERER&#39;] ）</p><h2 id="从浏览器输入网址到页面显示-发生了什么" tabindex="-1">从浏览器输入网址到页面显示，发生了什么？ <a class="header-anchor" href="#从浏览器输入网址到页面显示-发生了什么" aria-label="Permalink to &quot;从浏览器输入网址到页面显示，发生了什么？&quot;">​</a></h2><p>1.浏览器解析url 2.DNS查找真正的ip； 3.与服务器三次握手，建立tcp连接； 4.发起http请求 5.服务器处理请求，并返回HTTP报文 6.浏览器解析渲染页面 7.连接结束</p><h2 id="dns的作用" tabindex="-1">DNS的作用？ <a class="header-anchor" href="#dns的作用" aria-label="Permalink to &quot;DNS的作用？&quot;">​</a></h2><p>是一个将域名和IP地址相互映射的域名系统。</p><p>解析过程（分级解析）： 根域名 — 顶级域名 — 二级域名</p><p>步骤（递归查询本地服务器，迭代查询其他远程服务器）：</p><p>看看DNS缓存里有没有，有的话直接返回； 使用UDP向DNS服务器发送查询消息； 接收返回的响应消息；</p><h2 id="dns的解析过程" tabindex="-1">DNS的解析过程？ <a class="header-anchor" href="#dns的解析过程" aria-label="Permalink to &quot;DNS的解析过程？&quot;">​</a></h2><p>就是为了找ip 1.检查浏览器缓存，找ip 2.本地DNS服务器缓存中 3.根域名服务器，告诉本地DNS服务器去哪个顶级域名域名服务器查找 4.顶级域名服务器查找，告诉本地DNS服务器去哪个权限域名服务器查找 5.权限域名服务器告诉哪个ip</p><h1 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h1><p>TCP是一个可靠的，面向连接，基于字节流，全双工的协议 面向连接：发送数据前要进行握手，断开要挥手 可靠：对包校验和;包的序列号解决重复，乱序的问题；超时重传；流量控制，拥塞控制 基于字节流：没有边界（\\r\\n区分） 全双工：在 TCP 中发送端和接收端可以是客户端/服务端，也可以是服务器/客户端，通信的双方在任意时刻既可以是接收数据也可以是发送数据，每个方向的数据流都独立管理序列号、滑动窗口大小、MSS 等信息。</p><h2 id="tcp和udp的区别" tabindex="-1">TCP和UDP的区别？ <a class="header-anchor" href="#tcp和udp的区别" aria-label="Permalink to &quot;TCP和UDP的区别？&quot;">​</a></h2><blockquote><p>tcp是面向连接，可靠的传输层协议，只能一对一，全双工，使用场景：http,ssh,smtp等<br> tcp是无连接的，一对一，多对多全都行，使用场景：dns</p></blockquote><table tabindex="0"><thead><tr><th style="text-align:center;">对比项</th><th style="text-align:center;">UDP</th><th style="text-align:center;">TCP</th></tr></thead><tbody><tr><td style="text-align:center;">连接性</td><td style="text-align:center;">无连接</td><td style="text-align:center;">面向连接</td></tr><tr><td style="text-align:center;">可靠性</td><td style="text-align:center;">不可靠</td><td style="text-align:center;">可靠</td></tr><tr><td style="text-align:center;">报文</td><td style="text-align:center;">面向报文-数据报模式</td><td style="text-align:center;">面向字节流-流模式</td></tr><tr><td style="text-align:center;">双工性</td><td style="text-align:center;">一对一、一对多、多对一、多对多</td><td style="text-align:center;">全双工</td></tr><tr><td style="text-align:center;">流量控制</td><td style="text-align:center;">无</td><td style="text-align:center;">有(滑动窗口)</td></tr><tr><td style="text-align:center;">拥塞控制</td><td style="text-align:center;">无</td><td style="text-align:center;">有(慢开始、拥塞避免、快重传、快恢复)</td></tr><tr><td style="text-align:center;">传输速度</td><td style="text-align:center;">快</td><td style="text-align:center;">慢</td></tr><tr><td style="text-align:center;">资源要求</td><td style="text-align:center;">较少</td><td style="text-align:center;">较多</td></tr><tr><td style="text-align:center;">首部开销</td><td style="text-align:center;">8字节</td><td style="text-align:center;">20字节</td></tr><tr><td style="text-align:center;">数据顺序</td><td style="text-align:center;">不保证</td><td style="text-align:center;">保证</td></tr></tbody></table><h2 id="tcp是如何保证可靠性的" tabindex="-1">TCP是如何保证可靠性的？ <a class="header-anchor" href="#tcp是如何保证可靠性的" aria-label="Permalink to &quot;TCP是如何保证可靠性的？&quot;">​</a></h2><blockquote><p>1.连接基于三次握手，断开基于四次挥手，保证了连接和断开的可靠性<br> 2.TCP是有状态的传输协议；会记录哪些数据发送了，哪些接受了，哪些没接受，并且保证包的有序到达，<br> 3.可控性：数据包校验，ACK应答，超时重传（发送方），失序数据重传（接收方），丢弃重复数据，流量控制（滑动窗口，控制拥塞），等</p></blockquote><h2 id="tcp-ip如何保证包的传输的有序性" tabindex="-1">TCP/IP如何保证包的传输的有序性？ <a class="header-anchor" href="#tcp-ip如何保证包的传输的有序性" aria-label="Permalink to &quot;TCP/IP如何保证包的传输的有序性？&quot;">​</a></h2><p>对字节流分段并进行编号然后通过 ACK 应答和超时重发这两个机制来保证。 （1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区； （2）并为每个已发送的数据包启动一个超时定时器； （3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区; （4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。 （5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h2 id="半连接是什么" tabindex="-1">半连接是什么？ <a class="header-anchor" href="#半连接是什么" aria-label="Permalink to &quot;半连接是什么？&quot;">​</a></h2><p>当客户端发syn到服务端，服务端收到后回syn+ack，服务端的tcp从listen状态变为syn_rcvd,会将连接信息放入队列（半连接队列）</p><h2 id="tcp粘包-怎么发送" tabindex="-1">TCP粘包？怎么发送？ <a class="header-anchor" href="#tcp粘包-怎么发送" aria-label="Permalink to &quot;TCP粘包？怎么发送？&quot;">​</a></h2><p>Tcp粘（年）包是指发送方发送若干个包到接收方，接收方接收时粘在一起了，前一个包的后头紧接者包的头。 通过特殊字符区分边界，比如\\r\\n</p><h2 id="tcp流量控制" tabindex="-1">TCP流量控制 <a class="header-anchor" href="#tcp流量控制" aria-label="Permalink to &quot;TCP流量控制&quot;">​</a></h2><p>TCP流量控制的核心就是动态地调整发送窗口和接收窗口的大小 流量控制是为了调整发送方的发送速率，使得接收方来得及接收。<br> 接收方的确认报文中有一个窗口字段，用来控制发送方的窗口大小，从而控制发送速率。<br> 发送窗口(swmd=min(rwmd,cwmd))，接收窗口(rwnd，接收端)，拥塞窗口(cwmd,发送端的)；偏移量,序号(seq) Seq=x,rwnd=200,接收者返回窗口的大小，可以动态调整</p><h2 id="tcp超时重传" tabindex="-1">TCP超时重传？ <a class="header-anchor" href="#tcp超时重传" aria-label="Permalink to &quot;TCP超时重传？&quot;">​</a></h2><p>将数据包未ack的重新传一遍</p><h2 id="tcp滑动窗口" tabindex="-1">TCP滑动窗口？ <a class="header-anchor" href="#tcp滑动窗口" aria-label="Permalink to &quot;TCP滑动窗口？&quot;">​</a></h2><p>如果tcp传一段，应答一段，那性能会更差；为了更快地传输，所以就有了滑动窗口。 会设定了窗口的大小， 开始会按照窗口的大小发送数据段，然后ack的偏移量，进行滑动这个窗口。 出现丢失会进行重传，在将后边的数据段继续发送</p><p>假设发送100字节的数据包,每次发送的长度就是窗口的大小; 假设窗口大小是5字节,一开是从0到4发送; 返回了0，1，3，4的ack，2没成功； 就会定时重传，法松2位置的包，直到成功； 发送过程中，接收方告知能它的接收窗口多大，能处理多少，然后会调整发送窗口的大小； 全部发送成功之后，就将窗口滑动到5-10(假设窗口还是6)</p><h2 id="tcp拥塞控制" tabindex="-1">TCP拥塞控制？ <a class="header-anchor" href="#tcp拥塞控制" aria-label="Permalink to &quot;TCP拥塞控制？&quot;">​</a></h2><p>网络出现拥堵时，可能会出现数据丢失，延时；这是tcp会重传数据，但是重传可能导致更多的延时和丢失，导致恶性循环。为了避免这些情况，就有了拥塞控制。 过程： 1.三次握手后，双方通过ack告诉对方接收窗(rwnd)口的大小 2.双方初始化拥塞窗口(cwnd)的大小 3.cwnd初始值较小，每收一个ack就+1，每经过一个rtt(往返时间),就变为2倍</p><p>拥塞窗口:只要网络无故障，就会不断增大;反之减少; 发送窗口=min(接收窗口,拥塞窗口(发送端的)); 算法：慢启动,拥塞避免，快速重传和快速恢复 慢启动阈(玉)值(ssthresh) Cwnd &lt;ssthresh,慢启动； Cwnd&gt;ssthresh,拥塞避免； 慢启动:拥塞窗口的初始值很小(linux默认10)，随着时间推移，一直不丢包的话，拥塞窗口的值会越来越大。 拥塞避免：每一个rtt(往返时间)，+1； 快速重传和快速恢复： 收到不按顺序的数据段时，tcp就发送重复的ack，当发了3个重复ack，就意识到丢包了，进行重传 三次重复ack，进入快快速恢复，拥塞阈值和拥塞窗口变为1半，拥塞窗口线性增加</p><h2 id="tcp-keepalived-是什么-有什么作用" tabindex="-1">TCP keepalived 是什么，有什么作用 <a class="header-anchor" href="#tcp-keepalived-是什么-有什么作用" aria-label="Permalink to &quot;TCP keepalived 是什么，有什么作用&quot;">​</a></h2><p>该机制用于检测TCP连接是否存活；</p><h2 id="三次握手的过程" tabindex="-1">三次握手的过程？ <a class="header-anchor" href="#三次握手的过程" aria-label="Permalink to &quot;三次握手的过程？&quot;">​</a></h2><p>三次握手就是建立tcp连接时要发三个包 1.第一次握手，客户端发送（SYN=1，seq=x）的包，发送后，客户端进入SYN_SEND状态 2.第二次握手，服务端发（SYN=1，ACK=1，seq=y,ACKnum=x+1）的包，发送后，服务端进入SYN_REV状态 3.第三次握手，客户端发（ACK=1，ACKnum=y+1）的包，客户端进入ESTABLISHED 状态，建立三次握手 第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><h2 id="四次挥手的过程" tabindex="-1">四次挥手的过程？ <a class="header-anchor" href="#四次挥手的过程" aria-label="Permalink to &quot;四次挥手的过程？&quot;">​</a></h2><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p><p>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>',96)])])}const P=e(o,[["render",s]]);export{T as __pageData,P as default};
