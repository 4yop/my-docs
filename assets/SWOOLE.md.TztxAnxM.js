import{_ as o,c as a,o as t,ae as l}from"./chunks/framework.BQlYxExx.js";const b=JSON.parse('{"title":"🚀 Swoole 高性能编程：协程、常驻内存与性能调优面试指南","description":"深度解析 Swoole 协程原理、进程/线程/协程区别，及常驻内存模型下的陷阱。全面掌握内存泄露、全局变量污染、扩展冲突等常见问题与解决方案，以及进程通信（Swoole\\\\Table、消息队列）和心跳机制配置。","frontmatter":{"title":"🚀 Swoole 高性能编程：协程、常驻内存与性能调优面试指南","description":"深度解析 Swoole 协程原理、进程/线程/协程区别，及常驻内存模型下的陷阱。全面掌握内存泄露、全局变量污染、扩展冲突等常见问题与解决方案，以及进程通信（Swoole\\\\Table、消息队列）和心跳机制配置。","keywords":"Swoole 面试题, Swoole 协程, Swoole 内存泄露, PHP 常驻内存, Swoole 性能优化, 进程 线程 协程区别, Swoole 进程通信, Swoole 心跳机制, PHP 高性能, Swoole Event 事件"},"headers":[],"relativePath":"SWOOLE.md","filePath":"SWOOLE.md"}'),r={name:"SWOOLE.md"};function s(i,e,n,c,h,d){return t(),a("div",null,[...e[0]||(e[0]=[l('<h1 id="swoole" tabindex="-1">swoole <a class="header-anchor" href="#swoole" aria-label="Permalink to &quot;swoole&quot;">​</a></h1><p><a href="https://wiki.swoole.com/zh-cn/#/" target="_blank" rel="noreferrer">文档</a></p><h2 id="使用swoole需要注意的" tabindex="-1">使用swoole需要注意的 <a class="header-anchor" href="#使用swoole需要注意的" aria-label="Permalink to &quot;使用swoole需要注意的&quot;">​</a></h2><p>扩展冲突(phptrace,aop,molten,xhprof,phalcon)<br> 不要使用sleep/usleep.会使整个进程阻塞(Swoole\\Timer::after()等)；协程中用Co::sleep或hook后的sleep;<br> 不要使用exit/die；worker进程会不断退出启动。<br> 有异常必须用try/catch捕捉（不支持set_exception_handler），否则退出工作进程；<br> 多个worker不能连同一个mysql或redis连接，会导致混乱；<br> 并发编程，协程上下文；<br> 常驻内存，不能重复定义function，类，请用include_once和require_once<br> 尽量使用局部变量，会回收；非局部变量global ,static $_GET等不会回收，一直追加可能造成内存泄露和溢出；（可max_request,task_worker_request worker进程task进程,运行次次数上限后自动退出，然后释放掉;onclose事件或定时器用unset清理）<br> 禁止使用$_GET/$_POST/$_REQUEST/$_SESSION/$_COOKIE/$_SERVER，等全局变量;<br> 进程隔离,一个进程修改某个值，其他进程是无法获取的；用 \\swoole\\table，Swoole\\Atomic(原子计数)，redis等来替代<br> 父进程mt_rand，导致子进程的值一样，用mt_srand重新播种<br> __get 和 __set 魔术方法里，不得产生协程切换；因为下次调用会被判定为循环调用(php底层)</p><h2 id="swoole内存泄露的原因" tabindex="-1">swoole内存泄露的原因？ <a class="header-anchor" href="#swoole内存泄露的原因" aria-label="Permalink to &quot;swoole内存泄露的原因？&quot;">​</a></h2><p>请勿在 onReceive 等回调函数中创建锁，否则内存会持续增长，造成内存泄漏。<br> 不要循环创建 / 销毁锁的对象，否则会发生内存泄漏。<br> 必须在 socket 的 close 操作前使用 Event::del 移除事件监听，否则可能会产生内存泄漏<br> 在事件回调函数中需要特别注意非局部变量的 array 类型值，某些操作如 TestClass::$array[] = &quot;string&quot; 可能会造成内存泄漏，严重时可能发生内存溢出，必要时应当注意清理大数组。<br> 在事件回调函数中，非局部变量的字符串进行拼接操作是必须小心内存泄漏，如 TestClass::$string .= $data，可能会有内存泄漏，严重时可能发生内存溢出。</p><h2 id="swoole-内存溢出" tabindex="-1">swoole 内存溢出 <a class="header-anchor" href="#swoole-内存溢出" aria-label="Permalink to &quot;swoole 内存溢出&quot;">​</a></h2><p>在事件回调函数中需要特别注意非局部变量的 array 类型值，某些操作如 TestClass::$array[] = &quot;string&quot; 可能会造成内存泄漏，严重时可能发生内存溢出，必要时应当注意清理大数组。<br> 在事件回调函数中，非局部变量的字符串进行拼接操作是必须小心内存泄漏，如 TestClass::$string .= $data，可能会有内存泄漏，严重时可能发生内存溢出</p><p>task_max_request(默认为0不退出),设置之后处理完超过此数值就自动退出</p><h2 id="swoole的协程" tabindex="-1">swoole的协程 <a class="header-anchor" href="#swoole的协程" aria-label="Permalink to &quot;swoole的协程&quot;">​</a></h2><p>可以理解为用户态的线程，不需要系统参与，创建和销毁成本更低，不同的是不能用多核cpu，要用需使用swoole多进程</p><h2 id="请说明socket监听端口9502在内存中大小端的layout" tabindex="-1">请说明socket监听端口9502在内存中大小端的layout <a class="header-anchor" href="#请说明socket监听端口9502在内存中大小端的layout" aria-label="Permalink to &quot;请说明socket监听端口9502在内存中大小端的layout&quot;">​</a></h2><h2 id="进程-多线程-协程的区别" tabindex="-1">进程，多线程，协程的区别 <a class="header-anchor" href="#进程-多线程-协程的区别" aria-label="Permalink to &quot;进程，多线程，协程的区别&quot;">​</a></h2><ul><li>进程：进程是操作系统进行资源分配和调度的基本单位，是程序的实体。每个进程都有自己的独立地址空间和系统资源。进程之间不共享全局变量，因此，多进程程序的安全性较高，但资源开销较大。</li><li>多线程：线程是程序执行中的一个单一的顺序控制流程，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，同一进程中的多个线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈和线程本地存储。由于线程之间能够共享地址空间，因此，需要考虑同步和互斥操作。一个线程的意外终止会影响整个进程的正常运行。</li><li>协程：协程是存在于单个线程中的不同执行流，通过显式调用进行切换来实现非阻塞的异步操作，同时共享相同的数据空间。协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。协程的切换是由程序自身控制的，而不是像线程那样由操作系统进行调度，因此效率更高。 总的来说，多进程程序安全性高，进程切换开销大，效率低；多线程程序维护成本高，线程切换开销小，效率高；协程则是异步的，切换开销极小，效率极高。希望这个解答能帮助你理解这三者的区别。</li></ul><blockquote><p>是否有向静态属性，静态变量，全局变量追加数据，use &amp;$变量<br> 扩展在fpm没问题，在cli可能就有问题<br> 有钱用Swoole Tracker<br> 请求周期（onrequest等）内对全局对象赋值，并且请求结束后没有释放<br> new 类，方法启用swoole服务，无法释放 那个类<br> 1.global 2.类的静态熟悉 3.函数的静态变量 4.无法结束的函数的局部变量</p></blockquote><h2 id="在linux下启动swoole配置daemonize和不配做daemonize时有什么区别-不配置时为什么ctrl-c就退出了" tabindex="-1">在linux下启动swoole配置daemonize和不配做daemonize时有什么区别？不配置时为什么ctrl+c就退出了？ <a class="header-anchor" href="#在linux下启动swoole配置daemonize和不配做daemonize时有什么区别-不配置时为什么ctrl-c就退出了" aria-label="Permalink to &quot;在linux下启动swoole配置daemonize和不配做daemonize时有什么区别？不配置时为什么ctrl+c就退出了？&quot;">​</a></h2><h2 id="swoole的http-websocket协议的实现原理是什么-给出伪代码" tabindex="-1">swoole的http/websocket协议的实现原理是什么？给出伪代码 <a class="header-anchor" href="#swoole的http-websocket协议的实现原理是什么-给出伪代码" aria-label="Permalink to &quot;swoole的http/websocket协议的实现原理是什么？给出伪代码&quot;">​</a></h2><h2 id="swoole的event事件的工作原理" tabindex="-1">swoole的Event事件的工作原理 <a class="header-anchor" href="#swoole的event事件的工作原理" aria-label="Permalink to &quot;swoole的Event事件的工作原理&quot;">​</a></h2><h2 id="伪代码说明swoole协程切换的原理" tabindex="-1">伪代码说明swoole协程切换的原理 <a class="header-anchor" href="#伪代码说明swoole协程切换的原理" aria-label="Permalink to &quot;伪代码说明swoole协程切换的原理&quot;">​</a></h2><h2 id="请简述协程工作机制和协程栈空间地址变化" tabindex="-1">请简述协程工作机制和协程栈空间地址变化 <a class="header-anchor" href="#请简述协程工作机制和协程栈空间地址变化" aria-label="Permalink to &quot;请简述协程工作机制和协程栈空间地址变化&quot;">​</a></h2><h2 id="websocket拒绝服务攻击" tabindex="-1">websocket拒绝服务攻击？ <a class="header-anchor" href="#websocket拒绝服务攻击" aria-label="Permalink to &quot;websocket拒绝服务攻击？&quot;">​</a></h2><h2 id="swoole进程间的通信方式-还有哪些通信方式" tabindex="-1">swoole进程间的通信方式？还有哪些通信方式？ <a class="header-anchor" href="#swoole进程间的通信方式-还有哪些通信方式" aria-label="Permalink to &quot;swoole进程间的通信方式？还有哪些通信方式？&quot;">​</a></h2><p>管道(pipe) 命名管道(named pipe)<br> 消息队列(message queue) useQueue() 后 push pop<br> 共享内存(shared memory) 用swoole\\table或redis等<br> 套字节(socket,unixsock) 使用 Process::exportSocket() send() recv()<br> 信号量() <code>Swoole\\Process::kill(int $pid, int $signo = SIGTERM): bool</code><br> 文件映射(memory-mapped file)<br><a href="https://wiki.swoole.com/zh-cn/#/process/process_pool" target="_blank" rel="noreferrer">文档</a></p><h2 id="常驻进程-mysql超时如何处理" tabindex="-1">常驻进程，mysql超时如何处理？ <a class="header-anchor" href="#常驻进程-mysql超时如何处理" aria-label="Permalink to &quot;常驻进程，mysql超时如何处理？&quot;">​</a></h2><p>1.重试 2.定时发送心跳维持连接 <code>$server-&gt;set([ &#39;open_tcp_keepalive&#39; =&gt; true,//启用 TCP keepalive &#39;tcp_keepidle&#39; =&gt; 4, //4s没有数据传输就进行检测 &#39;tcp_keepinterval&#39; =&gt; 1, //1s探测一次 &#39;tcp_keepcount&#39; =&gt; 5, //探测的次数，超过5次后还没回包close此连接 &#39;heartbeat_idle_time&#39; =&gt; 600, // 表示一个连接如果600秒内未向服务器发送任何数据，此连接将被强制关闭 &#39;heartbeat_check_interval&#39; =&gt; 60, // 启用心跳检测，连接最大允许空闲的时间,表示每60秒遍历一次 ]);</code></p>',25)])])}const p=o(r,[["render",s]]);export{b as __pageData,p as default};
